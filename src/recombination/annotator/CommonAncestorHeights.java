/*
 * Copyright (C) 2015 Tim Vaughan <tgvaughan@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package recombination.annotator;

import beast.core.util.Log;
import beast.evolution.tree.Tree;
import beast.math.statistic.DiscreteStatistics;
import recombination.network.BreakPoints;
import recombination.network.RecombinationNetwork;
import recombination.network.RecombinationNetworkEdge;
import recombination.network.RecombinationNetworkNode;
import recombination.statistics.DotConverter;

import javax.swing.*;
import javax.swing.border.EtchedBorder;
import java.awt.*;
import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.util.*;
import java.util.List;

/**
 * A rewrite of TreeAnnotator targeted at summarizing ACG logs
 * generated by bacter.
 * 
 * @author Tim Vaughan <tgvaughan@gmail.com>
 * @author Nicola Felix MÃ¼ller <nicola.felix.mueller@gmail.com>
 */
public class CommonAncestorHeights extends RecombinationAnnotator {

    private enum SummaryStrategy { MEAN, MEDIAN }

    private static class NetworkAnnotatorOptions {
        File inFile;
        File outFile = new File("commonAncestorHeights.tsv");
        String sequence;
        double burninPercentage = 10.0;
        SummaryStrategy summaryStrategy = SummaryStrategy.MEAN;
        boolean rootOnly = false;
        BreakPoints breakPoints = new BreakPoints();

        @Override
        public String toString() {
            return "Active options:\n" +
                    "Input file: " + inFile + "\n" +
                    "Output file: " + outFile + "\n" +
                    "Sequence: " + sequence + "\n" +
                    "Burn-in percentage: " + burninPercentage + "\n" +
                    "Node height and conv. site summary: " + summaryStrategy + "\n" +
            		"Remove Loci for summary: " + breakPoints + "\n" +
            		"root only: " + rootOnly + "\n";
       }
    }

    public CommonAncestorHeights(NetworkAnnotatorOptions options) throws IOException {
        // Display options:
        System.out.println(options + "\n");
                
        // Initialise reader
        RecombinationLogReader logReader = new RecombinationLogReader(options.inFile,
                options.burninPercentage);

        System.out.println(logReader.getNetworkCount() + " Networks in file.");

        System.out.println("The first " + logReader.getBurnin() +
                 " (" + options.burninPercentage + "%) ACGs will be discarded " +
                "to account for burnin.");
        List<String> leafNodes = new ArrayList<>();
        
        if (options.rootOnly) {
	        double[][] rootHeight = new double[0][0];          
	        boolean first = true;
	        int i = 0;
	        for (RecombinationNetwork network : logReader){
	        	if (first) {
	            	rootHeight = new double[logReader.getCorrectedNetworkCount()][network.totalLength];
	                first = false;
	        	}
	        	network.setEverythingDirty(false);
	        	getRootHeights(network.getRootEdge(), rootHeight[i], network.getRootEdge().breakPoints);
	        	i++;
	        }

	        
	        System.out.println("\nComputing CF clade credibilities...");
	        // calculate the network clade credibilities      
	        
	    	// print the network to file
	        System.out.println("\nWriting output to " + options.outFile.getName()
	        	+ "...");
	        try (PrintStream ps = new PrintStream(options.outFile)) {
	        	ps.print("position\tmean\tmedian\tlower\tupper\n");
	        	
        		for (int b = 0; b < rootHeight[0].length; b++) {
            		double[] heightarray = new double[logReader.getCorrectedNetworkCount()];
            		for (int c = 0; c < logReader.getCorrectedNetworkCount(); c++) {
            			heightarray[c] = rootHeight[c][b];
            		}
            		
                    Arrays.sort(heightarray);
                    double minHPD = heightarray[(int)(0.025 * heightarray.length)];
                    double maxHPD = heightarray[(int)(0.975 * heightarray.length)];

                    ps.print(b + "\t");
                    ps.print(DiscreteStatistics.mean(heightarray) + "\t");
                    ps.print(DiscreteStatistics.median(heightarray) + "\t");

                    ps.print(minHPD + "\t");
                    ps.print(maxHPD + "\n");
        		}
	        	
	        }      
	
	        System.out.println("\nDone!");

        
        }else {	
	        double[][][] nodeHeights = new double[0][0][0];          
	        // build the clades
	        boolean first = true;
	        int i = 0;
	        for (RecombinationNetwork network : logReader){
	        	if (first) {
	            	for (RecombinationNetworkNode networkNode : network.getNodes()){
	            		if (networkNode.isLeaf()){
	            			if (!networkNode.getTaxonLabel().contentEquals(options.sequence))
	            				leafNodes.add(networkNode.getTaxonLabel());
	            		}
	        		}
	        		nodeHeights = new double[logReader.getCorrectedNetworkCount()][network.totalLength][leafNodes.size()];
	                first = false;
	        	}
	        	network.setEverythingDirty(false);
	        	getNodeHeights(network, options.sequence, leafNodes, nodeHeights[i]);	        	
	        	i++;
	        }
	        
	        
	        System.out.println("\nComputing CF clade credibilities...");
	        // calculate the network clade credibilities      
	        
	    	// print the network to file
	        System.out.println("\nWriting output to " + options.outFile.getName()
	        	+ "...");
	        try (PrintStream ps = new PrintStream(options.outFile)) {
	        	ps.print("position\tmean\tmedian\tlower\tupper\tname\n");
	        	
	        	for (int a = 0; a < leafNodes.size() - 1; a++) {
	        		for (int b = 0; b < nodeHeights[0].length; b++) {
	            		double[] heightarray = new double[logReader.getCorrectedNetworkCount()];
	            		for (int c = 0; c < logReader.getCorrectedNetworkCount(); c++) {
	            			heightarray[c] = nodeHeights[c][b][a];
	            		}
	            		
	                    Arrays.sort(heightarray);
	                    double minHPD = heightarray[(int)(0.025 * heightarray.length)];
	                    double maxHPD = heightarray[(int)(0.975 * heightarray.length)];
	
	                    ps.print(b + "\t");
	                    ps.print(DiscreteStatistics.mean(heightarray) + "\t");
	                    ps.print(DiscreteStatistics.median(heightarray) + "\t");
	
	                    ps.print(minHPD + "\t");
	                    ps.print(maxHPD + "\t");
	                    ps.print(leafNodes.get(a) + "\n");
	        		}
	        	} 
	        }      
	
	        System.out.println("\nDone!");
        }
    }   
    
 
	private void getNodeHeights(RecombinationNetwork network, String sequence,
			List<String> leafNodes, double[][] commonAncestorHeights) {
    	// get the leaf that equals sequence
    	for (RecombinationNetworkNode leaf : network.getLeafNodes()) {
    		if (leaf.getTaxonLabel().contentEquals(sequence)) {
    			RecombinationNetworkEdge edge = leaf.getParentEdges().get(0);
    			upwardsPassing(edge, edge.breakPoints.copy(), commonAncestorHeights, leafNodes);
    		}
    	}   	
    	
	}
	
	private void getRootHeights(RecombinationNetworkEdge edge, double[] commonAncestorHeights, BreakPoints bp_in) {
		BreakPoints bp = bp_in.copy();
		bp.and(edge.breakPoints);
		if (bp.isEmpty())
			return;
				
		
		RecombinationNetworkNode n = edge.childNode;
		if (n.isCoalescence()) {
			BreakPoints overlap = n.getChildEdges().get(0).breakPoints.copy();
			overlap.and(n.getChildEdges().get(1).breakPoints);
			if (!overlap.isEmpty()) {
				bp.andNot(overlap);
				
				for (int j = 0; j < overlap.size(); j++) {
					for (int k = overlap.getRange(j).from; k <= overlap.getRange(j).to; k++) {
						commonAncestorHeights[k] = n.getHeight();						
					}
				}
			}			
		}
		if (n.isLeaf()) {
			return;
		}

		for (RecombinationNetworkEdge e : n.getChildEdges()) {
			getRootHeights(e, commonAncestorHeights, bp);
		}

		
	}


	private void upwardsPassing(RecombinationNetworkEdge edge, BreakPoints currBP, double[][] commonAncestorHeights, List<String> leafNodes) {
		RecombinationNetworkNode node = edge.parentNode;
		
		if (edge.isRootEdge()) {
			return;		
		}
		
		if (node.isCoalescence()) {
			// check if it's a loop
			if (node.getChildEdges().get(1).childNode.ID != node.getChildEdges().get(0).childNode.ID) {
				// check which edge is which
				RecombinationNetworkEdge otherEdge = node.getChildEdges().get(0).childNode.ID == edge.childNode.ID ? node.getChildEdges().get(1) : node.getChildEdges().get(0);
				BreakPoints bp = currBP.copy();
				bp.and(otherEdge.breakPoints);
				if (!bp.isEmpty()) {
					downwardsPassing(otherEdge, bp, commonAncestorHeights, node.getHeight(), leafNodes);
				}			
			}
			upwardsPassing(node.getParentEdges().get(0), currBP, commonAncestorHeights, leafNodes);			
		}else {
			for (RecombinationNetworkEdge e : node.getParentEdges()) {
				BreakPoints bp = currBP.copy();
				bp.and(e.breakPoints);
				if (!bp.isEmpty())
					upwardsPassing(e, bp, commonAncestorHeights, leafNodes);
			}
		}
	}

	private void downwardsPassing(RecombinationNetworkEdge edge, BreakPoints currBP, double[][] commonAncestorHeights,
			double height, List<String> leafNodes) {
		
		RecombinationNetworkNode node = edge.childNode;
		
		edge.makeDirty(Tree.IS_FILTHY);

		if (currBP.isEmpty())
			return;
		
		if (node.isLeaf()) {
			for (int i = 0; i < leafNodes.size(); i++) {
				if (leafNodes.get(i).contentEquals(node.getTaxonLabel())) {
					for (int j = 0; j < currBP.size(); j++) {
						for (int k = currBP.getRange(j).from; k <= currBP.getRange(j).to; k++) {
							commonAncestorHeights[k][i] = height;						
						}
					}
				}
			}
			return;
		}else if (node.isCoalescence()) {
			for (RecombinationNetworkEdge e : node.getChildEdges()) {
				BreakPoints bp = currBP.copy();
				bp.and(e.breakPoints);
				downwardsPassing(e, bp, commonAncestorHeights, height, leafNodes);
			}
		}else {
			downwardsPassing(node.getChildEdges().get(0), currBP, commonAncestorHeights, height, leafNodes);
		}			
	}
	
    public static String helpMessage =
            "ACGAnnotator - produces summaries of Bacter ACG log files.\n"
                    + "\n"
                    + "Usage: appstore ACGAnnotator [-help | [options] logFile [outputFile]\n"
                    + "\n"
                    + "Option                   Description\n"
                    + "--------------------------------------------------------------\n"
                    + "-help                    Display usage info.\n"
                    + "-positions {mean,median} Choose position summary method.\n"
                    + "                         (default mean)\n"
                    + "-burnin percentage       Choose _percentage_ of log to discard\n"
                    + "                         in order to remove burn-in period.\n"
                    + "                         (Default 10%)\n"
                    + "-threshold percentage    Choose minimum posterior probability\n"
                    + "                         for including conversion in summary.\n"
                    + "                         (Default 50%)\n"
                    + "-recordGeneFlow gfFile   Record posterior distribution of gene\n"
                    + "                         flow in given file.\n"
                    + "\n"
                    + "If no output file is specified, output is written to a file\n"
                    + "named 'summary.tree'.";

    /**
     * Print usage info and exit.
     */
    public static void printUsageAndExit() {
        System.out.println(helpMessage);
        System.exit(0);
    }

    /**
     * Display error, print usage and exit with error.
     */
    public static void printUsageAndError(String errMsg) {
        System.err.println(errMsg);
        System.err.println(helpMessage);
        System.exit(1);
    }

    /**
     * Main method for ACGAnnotator.  Sets up GUI if needed then
     * uses the ACGAnnotator constructor to actually perform the analysis.
     *
     * @param args command line arguments
     */
    public static void main(String[] args) {
    	NetworkAnnotatorOptions options = new NetworkAnnotatorOptions();
    	
        getCLIOptions(args, options);

        // Run ACGAnnotator
        try {
            new CommonAncestorHeights(options);

        } catch (Exception e) {
            if (args.length == 0) {
                JOptionPane.showMessageDialog(null, e.getMessage(),
                        "Error", JOptionPane.ERROR_MESSAGE);
            } else {
                System.err.println("Error: " + e.getMessage());
                e.printStackTrace();
                System.err.println();
                System.err.println(helpMessage);
            }

            System.exit(1);
        }
    }
    
    
    /**
     * Retrieve ACGAnnotator options from command line.
     *
     * @param args command line arguments
     * @param options object to populate with options
     */
    public static void getCLIOptions(String[] args, NetworkAnnotatorOptions options) {
        int i=0;
        while (args[i].startsWith("-")) {
            switch(args[i]) {
                case "-help":
                    printUsageAndExit();
                    break;

                case "-burnin":
                    if (args.length<=i+1)
                        printUsageAndError("-burnin must be followed by a number (percent)");

                    try {
                        options.burninPercentage = Double.parseDouble(args[i+1]);
                    } catch (NumberFormatException e) {
                        printUsageAndError("Error parsing burnin percentage.");
                    }

                    if (options.burninPercentage<0 || options.burninPercentage>100) {
                        printUsageAndError("Burnin percentage must be >= 0 and < 100.");
                    }

                    i += 1;
                    break;

                case "-positions":
                    if (args.length<=i+1) {
                        printUsageAndError("-positions must be followed by either 'MEAN' or 'MEDIAN'.");
                    }

                    if (args[i+1].toLowerCase().equals("mean")) {
                        options.summaryStrategy = SummaryStrategy.MEAN;

                        i += 1;
                        break;
                    }

                    if (args[i+1].toLowerCase().equals("median")) {
                        options.summaryStrategy = SummaryStrategy.MEDIAN;

                        i += 1;
                        break;
                    }

                    printUsageAndError("-positions must be followed by either 'MEAN' or 'MEDIAN'.");

                case "-subsetRange":
                    if (args.length<=i+1) {
                        printUsageAndError("-subsetRange must be a range in the format of 0-100.");
                    }

                    try {
                    	String[] argarray = args[i + 1].split(",");
                    	List<Integer> bp_list = new ArrayList<>();
                    	for (int j = 0; j < argarray.length; j++) {
                    		String[] tmp = argarray[j].split("-");
                    		bp_list.add(Integer.parseInt(tmp[0]));
                    		bp_list.add(Integer.parseInt(tmp[1]));
                    	}
                		options.breakPoints.init(bp_list);
                    } catch (NumberFormatException e) {
                        printUsageAndError("removeSegments must be an array of integers separated by commas if more than one");
                     }

                    i += 1;
                    break;
                    
                case "-sequence":
                    if (args.length<=i+1) {
                        printUsageAndError("-sequence must be followed by a sequence name.");
                    }

                    try {
                		options.sequence = args[i + 1];
                    } catch (NumberFormatException e) {
                        printUsageAndError("removeSegments must be an array of integers separated by commas if more than one");
                     }

                    i += 1;
                    break;
                    
                case "-rootOnly":
                    if (args.length<=i+1) {
                        printUsageAndError("-rootOnly must false or true.");
                    }
                    
                    try {
                        options.rootOnly = Boolean.parseBoolean(args[i+1]);
                    } catch (NumberFormatException e) {
                        printUsageAndError("Error parsing rootOnly.");
                    }

                    i += 1;
                    break;

            }

            i += 1;
        }

        if (i >= args.length)
            printUsageAndError("No input file specified.");
        else
            options.inFile = new File(args[i]);

        if (i+1<args.length)
            options.outFile = new File(args[i+1]);
    }

}